from __future__ import annotations

from app.constants.score_status import ScoreStatus
from app.models.score import Score


def calculate_accuracy(score: Score) -> float:
    vanilla_mode = score.mode.as_vn

    n300 = score.n300
    n100 = score.n100
    n50 = score.n50

    ngeki = score.ngeki
    nkatu = score.nkatu

    nmiss = score.nmiss

    if vanilla_mode == 0:  # osu!
        total = n300 + n100 + n50 + nmiss

        if total == 0:
            return 0.0

        return (
            100.0 * ((n300 * 300.0) + (n100 * 100.0) + (n50 * 50.0)) / (total * 300.0)
        )

    elif vanilla_mode == 1:  # osu!taiko
        total = n300 + n100 + nmiss

        if total == 0:
            return 0.0

        return 100.0 * ((n100 * 0.5) + n300) / total

    elif vanilla_mode == 2:  # osu!catch
        total = n300 + n100 + n50 + nkatu + nmiss

        if total == 0:
            return 0.0

        return 100.0 * (n300 + n100 + n50) / total

    elif vanilla_mode == 3:  # osu!mania
        total = n300 + n100 + n50 + ngeki + nkatu + nmiss

        if total == 0:
            return 0.0

        return (
            100.0
            * (
                (n50 * 50.0)
                + (n100 * 100.0)
                + (nkatu * 200.0)
                + ((n300 + ngeki) * 300.0)
            )
            / (total * 300.0)
        )


def calculate_status(score: Score) -> None:
    if score.old_best:
        if score.pp > score.old_best.pp:
            score.status = ScoreStatus.BEST
            score.old_best.status = ScoreStatus.SUBMITTED
        elif score.pp == score.old_best.pp and score.score > score.old_best.score:
            # spin to win!
            score.status = ScoreStatus.BEST
            score.old_best.status = ScoreStatus.SUBMITTED
        else:
            score.status = ScoreStatus.SUBMITTED
    else:
        score.status = ScoreStatus.BEST
